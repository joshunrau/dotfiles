#!/usr/bin/env python
#
# TODO - Add support for optimizing music
# TODO - Test if video encoded on Linux with NVIDIA GPU is more performant on Jellyfin server

from __future__ import annotations

import json
import os
import sys

from argparse import ArgumentParser
from pathlib import Path
import shutil
from subprocess import CalledProcessError, run
from tempfile import mkdtemp
from typing import Any, Literal, Type, TypedDict


ARGS: Args
IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.webp']
VIDEO_EXTENSIONS = ['.mp4']

Encoding = Literal['H.264', 'H.265', 'UNKNOWN']
LogLevel = Literal['ERROR', 'WARNING', 'LOG', 'VERBOSE']


class Args(TypedDict):
    target: Path
    verbose: bool


class VideoStream(TypedDict):
    codec_name: str
    codec_long_name: str
    codec_type: Literal['audio', 'video']
    height: int
    width: int


class VideoInfo(TypedDict):
    encoding: Encoding
    filepath: Path
    height: int
    width: int


def log(*values: object, level: LogLevel = 'LOG') -> None:
    if level == 'ERROR':
        print(*('\033[91m{}\033[00m'.format(value) for value in values), file=sys.stderr)
    elif level == 'WARNING':
        print(*('\033[93m{}\033[00m'.format(value) for value in values), file=sys.stderr)
    elif level == 'LOG':
        print(*('\033[92m{}\033[00m'.format(value) for value in values))
    elif level == 'VERBOSE' and ARGS['verbose']:
        print(*('\033[97m{}\033[00m'.format(value) for value in values))


def get_property[T](dictionary: dict[str, Any], attr: str, expected_type: Type[T]) -> T:
    value = dictionary.get(attr)
    if not isinstance(value, expected_type):
        actual, expected = value.__class__.__name__, expected_type.__name__
        raise ValueError(f"Unexpected type '{actual}' for attribute '{attr}': expected '{expected}'")
    return value


def parse_args() -> Args:
    parser = ArgumentParser(prog='optimize-media')
    parser.add_argument('target', type=Path)
    parser.add_argument('--verbose', action='store_true')

    args = parser.parse_args()
    target: Path = args.target.resolve()

    if not target.is_dir():
        raise NotADirectoryError(target)

    return {'target': target, 'verbose': args.verbose}


def format_size(size: float) -> str:
    for unit in ('Bytes', 'KB', 'MB', 'GB', 'TB'):
        if abs(size) < 1024.0:
            return f'{size:3.1f}{unit}'
        size /= 1024.0
    return f'{size:.1f}PB'


def get_video_stream(streams: list[dict[str, Any]]) -> VideoStream | None:
    for stream in streams:
        if not isinstance(stream, dict):
            raise ValueError(f'Not a dict: {stream}')
        codec_type = stream.get('codec_type')
        if codec_type != 'video':
            continue
        return {
            'codec_name': get_property(stream, 'codec_name', str),
            'codec_long_name': get_property(stream, 'codec_long_name', str),
            'codec_type': codec_type,
            'height': get_property(stream, 'height', int),
            'width': get_property(stream, 'width', int),
        }
    return None


def get_video_info(filepath: Path) -> VideoInfo:
    cmd = f'ffprobe -v quiet -print_format json -show_streams "{filepath}"'
    result = run(cmd, capture_output=True, text=True, shell=True)
    try:
        try:
            result.check_returncode()
        except CalledProcessError as err:
            if result.stderr:
                log(result.stderr, level='ERROR')
            raise err

        output = json.loads(result.stdout)

        if not isinstance(output, dict):
            log(f'Command Output: {output}', level='ERROR')
            raise ValueError(f"Unexpected output for command '{cmd}': expected dict")

        streams = output.get('streams')
        if not isinstance(streams, list):
            log(f'Streams: {streams}', level='ERROR')
            raise ValueError('Unexpected value for streams: expected list')

        stream = get_video_stream(streams)
        if stream is None:
            log(f'Streams: {streams}', level='ERROR')
            raise RuntimeError('Failed to find video stream')

        encoding: Encoding
        if stream['codec_name'] == 'h264':
            encoding = 'H.264'
        elif stream['codec_name'] == 'hevc':
            encoding = 'H.265'
        else:
            encoding = 'UNKNOWN'
        return {'encoding': encoding, 'filepath': filepath, 'height': stream['height'], 'width': stream['width']}

    except Exception as err:
        raise RuntimeError(f'Failed to get video info for file {filepath}') from err


def optimize_video(video_info: VideoInfo) -> None:
    input_file = video_info['filepath']
    log(f'Optimizing video: {input_file}')
    input_size = os.path.getsize(input_file)
    tmp_dir = mkdtemp()
    log(f'Created directory: {tmp_dir}', level='VERBOSE')
    try:
        output_file = os.path.join(tmp_dir, 'output.mp4')
        cmd = f'ffmpeg -i "{input_file}" -preset fast -vcodec libx265 -crf 28 -tag:v hvc1 "{output_file}"'
        run(cmd, capture_output=True, shell=True)
        if not os.path.isfile(output_file):
            raise FileNotFoundError(f'Expected file to exist: {output_file}')
        log(f'Created file: {output_file}', level='VERBOSE')

        output_size = os.path.getsize(output_file)
        if output_size == 0:
            raise RuntimeError(f'Output file is empty: {output_file}')

        os.remove(input_file)
        shutil.move(output_file, input_file)

        diff = round(((output_size - input_size) / input_size) * 100, 1)
        if output_size > input_size:
            log(f'WARNING: Output file size exceeds input file size (+{diff}%)', level='WARNING')
        else:
            log(f'Done! Output filesize: {format_size(output_size)} ({diff}%)')

    except Exception as err:
        raise RuntimeError(f'Failed to optimize video: {input_file}') from err
    finally:
        if os.path.isdir(tmp_dir):
            shutil.rmtree(tmp_dir)


def main() -> None:
    log(f'Optimizing media in target directory: {ARGS['target']}')
    for root, _, files in os.walk(ARGS['target']):
        videos_to_optimize: list[VideoInfo] = []
        for filename in files:
            filepath = Path(os.path.join(ARGS['target'], root, filename))
            if filepath.suffix in VIDEO_EXTENSIONS:
                log(f'Found video: {filepath}', level='VERBOSE')
                video_info = get_video_info(filepath)
                if video_info['encoding'] != 'H.265':
                    videos_to_optimize.append(video_info)

    log(f'Found {len(videos_to_optimize)} video(s) to optimize')
    log(*[' ' * 4 + f'{video['filepath']}' for video in videos_to_optimize], level='VERBOSE')

    for index, video in enumerate(videos_to_optimize):
        log(f'{'-' * 5} VIDEO {index + 1}/{len(videos_to_optimize)} {'-' * 5}')
        # optimize_video(video)
        print(video)


if __name__ == '__main__':
    ARGS = parse_args()
    main()
